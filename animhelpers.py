import sys
import attr
from lxml import etree, builder
import subprocess
from itertools import count
from contextlib import contextmanager
import svgpathtools
import tinycss2
import math

__all__ = [
    # Entry point
    "make_anim",
    # Time
    "keep_time", "set_time", "wait",
    # SVG manipulation
    "set_initial_css", "animate", "slide",
    # High-level helpers
    "hidden", "LineSeq",
]

@attr.s
class GlobalState:
    svg = attr.ib()
    time = attr.ib()
    by_id = attr.ib()

GLOBAL_STATE = None

@contextmanager
def make_anim(in_svg, out_svg, *, minify=True):
    global GLOBAL_STATE
    inkscape = subprocess.Popen(
        [
            "inkscape",
            in_svg,
            "--without-gui",
            "--export-text-to-path",
            # Inkscape 0.92.4 can use "-" here, but I have 0.92.3
            "--export-plain-svg=/dev/stdout",
        ],
        stdout=subprocess.PIPE,
    )
    # remove_blank_text=True allows the pretty-printer to work better
    parser = etree.XMLParser(remove_blank_text=True)
    doc = etree.parse(inkscape.stdout, parser)
    svg = doc.getroot()

    svg.addprevious(etree.Comment(f"""
    THIS FILE IS AUTOGENERATED, DO NOT EDIT DIRECTLY
    source file: {in_svg}
    """))

    add_play_pause(svg)

    # Our own little getElementById
    by_id = {}
    for elem in doc.iter():
        if "id" in elem.attrib:
            assert elem.attrib["id"] not in by_id
            by_id[elem.attrib["id"]] = elem

    GLOBAL_STATE = GlobalState(svg=svg, time=0, by_id=by_id)
    try:
        yield
    finally:
        GLOBAL_STATE = None
    doc.write(
        out_svg + ".tmp",
        pretty_print=True, xml_declaration=True, encoding="UTF-8"
    )
    subprocess.run(["scour", "-i", out_svg + ".tmp", out_svg], check=True)


def viewbox(svg):
    return [float(x) for x in svg.attrib["viewBox"].split()]

def make_overlay(file, desired_x, desired_y, desired_size):
    svg = etree.parse(file).getroot()
    _, _, w, h = viewbox(svg)
    # Assume overlays are square
    assert math.isclose(w, h, rel_tol=1e-6)
    scale = desired_size / w
    # Pull out the main layer
    overlay = svg.find("{http://www.w3.org/2000/svg}g")
    # Strip off ids to avoid collisions with parent doc
    for elem in overlay.iter():
        if "id" in elem.attrib:
            del elem.attrib["id"]
    # Wrap in a transformed group and return
    g = E("g", transform=f"translate({desired_x} {desired_y}) scale({scale})")
    g.append(overlay)
    return g

def add_play_pause(main_svg):
    view_x, view_y, view_w, view_h = viewbox(main_svg)
    desired_size = 0.7 * min(view_w, view_h)
    desired_x = view_x + (view_w - desired_size) / 2
    desired_y = view_y + (view_h - desired_size) / 2
    play_elem = make_overlay(
        "play-overlay.svg", desired_x, desired_y, desired_size
    )
    play_elem.attrib["id"] = "play-overlay"
    main_svg.append(play_elem)
    replay_elem = make_overlay(
        "replay-overlay.svg", desired_x, desired_y, desired_size
    )
    replay_elem.attrib["id"] = "replay-overlay"
    replay_elem.attrib["style"] = "display: none; opacity: 0; transition: opacity 2s"
    main_svg.append(replay_elem)
    main_svg.append(E("script", open("player.js").read()))
    main_svg.attrib["onload"] = "init()"

def id_gen_fn():
    c = count()
    while True:
        yield f"animateStep{next(c)}"

id_gen = id_gen_fn()

@attr.s(frozen=True)
class TimeSpan:
    begin = attr.ib()
    end = attr.ib()

@attr.s(frozen=True)
class BaseTime:
    ref = attr.ib()
    offset = attr.ib(default=0)

    def __str__(self):
        if self.offset < 0:
            return f"{self.ref} - {-self.offset}s"
        else:
            return f"{self.ref} + {self.offset}s"

    def __add__(self, offset):
        return BaseTime(self.ref, self.offset + offset)

    def __sub__(self, offset):
        return self + -offset

def obj_to_time(obj):
    if isinstance(obj, str):
        return obj
    elif isinstance(obj, (int, float)):
        return f"{obj}s"
    elif isinstance(obj, BaseTime):
        return str(obj)
    assert False


@contextmanager
def keep_time():
    was = GLOBAL_STATE.time
    try:
        yield
    finally:
        GLOBAL_STATE.time = was

def set_time(t):
    GLOBAL_STATE.time = obj_to_time(t)

# Note: this really just moves you on the animation timeline, so you can wait
# negative time
def wait(offset):
    GLOBAL_STATE.time += offset


# Like lxml.builder.E, but with some extra conveniences:
# - adds required namespace to href=
# - strips trailing underscores so you can write from_=...
# - stringifies int/float attributes
def E(*args, **kwargs):
    fixed_kwargs = {}
    for k, v in kwargs.items():
        if k == "href":
            k = "{http://www.w3.org/1999/xlink}href"
        if k.endswith("_"):
            k = k.strip("_")
        if isinstance(v, (int, float)):
            v = str(v)
        fixed_kwargs[k] = v
    return builder.E(*args, **fixed_kwargs)


# There are a lot of ways to hide things in SVG/CSS â€“ display: none,
# visibility: 0, opacity: 0... we want to be able to fade hidden things in
# gradually, so that argues for using 'opacity'. But inkscape likes to stick
# 'opacity: 1' into style= attrs on individual elements, and those have high
# priority. We could use <set> to set "opacity: 0" on the first frame of the
# animation, but that can cause a flash of visibility... so instead we rewrite
# inkscape's style= attrs to remove the opacity:1, and then use CSS to set it.
# Kind of a big hammer, but it works.
def set_initial_css(whiches, name, value):
    for which in whiches:
        which_elem = GLOBAL_STATE.by_id[which]
        if "style" in which_elem.attrib:
            old_style = which_elem.attrib["style"]
            old_decls = tinycss2.parse_declaration_list(old_style)
            new_decls = [d for d in old_decls if d.name != name]
            which_elem.attrib["style"] = tinycss2.serialize(new_decls)
    # Put the <style> tag at the top of the doc, so the rendered sees it
    # before the relevant nodes
    selectors = ", ".join(f"#{which}" for which in whiches)
    GLOBAL_STATE.svg.insert(
        0, E("style", f"{selectors} {{ {name}: {value}; }}")
    )

def hidden(*whiches):
    set_initial_css(whiches, "opacity", 0)

# Create element, add it to the svg, give it an id, and return a TimeSpan
def add_SMIL_tag(*args, **kwargs):
    elem = E(*args, **kwargs)
    new_id = next(id_gen)
    elem.attrib["id"] = new_id
    elem.attrib["begin"] = obj_to_time(GLOBAL_STATE.time)
    GLOBAL_STATE.svg.append(elem)
    elem_ts = TimeSpan(BaseTime(f"{new_id}.begin"), BaseTime(f"{new_id}.end"))
    GLOBAL_STATE.time = elem_ts.end
    return elem_ts

# # Add a SMIL <set> tag
# def set(which, what, to):
#     add_SMIL_tag(
#         "set",
#         href="#" + which,
#         attributeName=what,
#         to=to,
#         fill="freeze",
#     )

# Add a SMIL <animate> tag
def animate(which, dur, what, **kwargs):
    return add_SMIL_tag(
        "animate",
        href="#" + which,
        dur=dur,
        fill="freeze",
        attributeName=what,
        **kwargs
    )

# Add a SMIL <animateMotion> tag for motion along an SVG path
def slide(which, dur, along):
    # Now we know that 'along' is being used as a motion path, rewrite the
    # path so that it starts at the origin.
    # XX: for debugging, might be useful to wrap it in a <g> with a transform
    # that reverses this, so it still appears in the same place in the
    # document?
    along_elem = GLOBAL_STATE.by_id[along]
    assert along_elem.tag == "{http://www.w3.org/2000/svg}path"
    path = svgpathtools.parse_path(along_elem.attrib["d"])
    new_path = path.translated(-path[0].start)
    assert new_path[0].start == 0+0j
    along_elem.attrib["d"] = new_path.d()
    # Then add the actual animateMotion tag
    return add_SMIL_tag(
        "animateMotion",
        E("mpath", href="#" + along),
        href="#" + which,
        dur=dur,
        # Easing
        calcMode="spline",
        keyPoints="0; 1",
        keyTimes="0; 1",
        keySplines="0.43 0.02 0.72 0.93",
        # Start from whereever it is right now, not the initial position
        additive="sum",
        # And after it arrives, it should stay there
        fill="freeze",
    )


@attr.s
class LineSeq:
    prefix = attr.ib()
    showing = attr.ib(default=0)
    first_missing = attr.ib(default=None)

    def __attrs_post_init__(self):
        # start with everything after {prefix}-0 hidden
        for i in count(1):
            if self._id(i) in GLOBAL_STATE.by_id:
                hidden(self._id(i))
            else:
                self.first_missing = i
                break

    def _id(self, i=None):
        if i is None:
            i = self.showing
        return f"{self.prefix}-{i}"

    def next(self):
        with keep_time():
            animate(self._id(), 1, "opacity", to=0)
        self.showing += 1
        animate(self._id(), 1, "opacity", from_=0, to=1)
        # if self.showing + 1 < self.first_missing:
        #     # If this is an intermediate line, make it throb
        #     with keep_time():
        #         animate(
        #             self._id(), 1, "opacity",
        #             values="1; 0.5; 1",
        #             repeatCount="indefinite",
        #         )

    def finish(self):
        self.next()
        assert self.showing + 1 == self.first_missing
