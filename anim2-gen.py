import sys
import attr
from lxml import etree, builder
import subprocess
from itertools import count
from contextlib import contextmanager
import svgpathtools
import tinycss2

INPUT = "anim2-assets.svg"

inkscape = subprocess.Popen(
    [
        "inkscape",
        INPUT,
        "--without-gui",
        "--export-text-to-path",
        # Inkscape 0.92.4 can use "-" here, but I have 0.92.3
        "--export-plain-svg=/dev/stdout",
    ],
    stdout=subprocess.PIPE,
)
# remove_blank_text=True allows the pretty-printer to work better
parser = etree.XMLParser(remove_blank_text=True)
doc = etree.parse(inkscape.stdout, parser)
svg = doc.getroot()

# Our own little getElementById
by_id = {}
for elem in doc.iter():
    if "id" in elem.attrib:
        assert elem.attrib["id"] not in by_id
        by_id[elem.attrib["id"]] = elem

svg.addprevious(etree.Comment(f"""
THIS FILE IS AUTOGENERATED, DO NOT EDIT DIRECTLY
source file: {INPUT}
"""))

def id_gen_fn():
    c = count()
    while True:
        yield f"animateStep{next(c)}"

id_gen = id_gen_fn()

@attr.s(frozen=True)
class TimeSpan:
    begin = attr.ib()
    end = attr.ib()

@attr.s(frozen=True)
class BaseTime:
    ref = attr.ib()
    offset = attr.ib(default=0)

    def __str__(self):
        if self.offset < 0:
            return f"{self.ref} - {-self.offset}s"
        else:
            return f"{self.ref} + {self.offset}s"

    def __add__(self, offset):
        return BaseTime(self.ref, self.offset + offset)

    def __sub__(self, offset):
        return self + -offset

def obj_to_time(obj):
    if isinstance(obj, str):
        return obj
    elif isinstance(obj, (int, float)):
        return f"{obj}s"
    elif isinstance(obj, BaseTime):
        return str(obj)
    assert False

TIME = 0

@contextmanager
def keep_time():
    global TIME
    was = TIME
    try:
        yield
    finally:
        TIME = was

def set_time(t):
    global TIME
    TIME = obj_to_time(t)

def sleep(offset):
    global TIME
    TIME += offset

# Like lxml.builder.E, but with some extra conveniences:
# - adds required namespace to href=
# - strips trailing underscores so you can write from_=...
# - stringifies int/float attributes
def E(*args, **kwargs):
    fixed_kwargs = {}
    for k, v in kwargs.items():
        if k == "href":
            k = "{http://www.w3.org/1999/xlink}href"
        if k.endswith("_"):
            k = k.strip("_")
        if isinstance(v, (int, float)):
            v = str(v)
        fixed_kwargs[k] = v
    return builder.E(*args, **fixed_kwargs)

# There are a lot of ways to hide things in SVG/CSS â€“ display: none,
# visibility: 0, opacity: 0... we want to be able to fade hidden things in
# gradually, so that argues for using 'opacity'. But inkscape likes to stick
# 'opacity: 1' into style= attrs on individual elements, and those have high
# priority. We could use <set> to set "opacity: 0" on the first frame of the
# animation, but that can cause a flash of visibility... so instead we rewrite
# inkscape's style= attrs to remove the opacity:1, and then use CSS to set it.
# Kind of a big hammer, but it works.
def set_initial_css(which, name, value):
    which_elem = by_id[which]
    if "style" in which_elem.attrib:
        old_style = which_elem.attrib["style"]
        old_decls = tinycss2.parse_declaration_list(old_style)
        new_decls = [d for d in old_decls if d.name != name]
        which_elem.attrib["style"] = tinycss2.serialize(new_decls)
    svg.append(E("style", f"#{which} {{ {name}: {value}; }}"))

def hidden(*whiches):
    for which in whiches:
        set_initial_css(which, "opacity", 0)

# Create element, add it to the svg, give it an id, and return a TimeSpan
def add_SMIL_tag(*args, **kwargs):
    global TIME
    elem = E(*args, **kwargs)
    new_id = next(id_gen)
    elem.attrib["id"] = new_id
    elem.attrib["begin"] = obj_to_time(TIME)
    svg.append(elem)
    elem_ts = TimeSpan(BaseTime(f"{new_id}.begin"), BaseTime(f"{new_id}.end"))
    TIME = elem_ts.end
    return elem_ts

# Add a SMIL <set> tag
def set(which, what, to):
    add_SMIL_tag(
        "set",
        href="#" + which,
        attributeName=what,
        to=to,
        fill="freeze",
    )

# Add a SMIL <animate> tag
def animate(which, dur, what, **kwargs):
    return add_SMIL_tag(
        "animate",
        href="#" + which,
        dur=dur,
        fill="freeze",
        attributeName=what,
        **kwargs
    )

# Add a SMIL <animateMotion> tag for motion along an SVG path
def slide(which, dur, along):
    # Now we know that 'along' is being used as a motion path, rewrite the
    # path so that it starts at the origin.
    # XX: for debugging, might be useful to wrap it in a <g> with a transform
    # that reverses this, so it still appears in the same place in the
    # document?
    along_elem = by_id[along]
    assert along_elem.tag == "{http://www.w3.org/2000/svg}path"
    path = svgpathtools.parse_path(along_elem.attrib["d"])
    new_path = path.translated(-path[0].start)
    assert new_path[0].start == 0+0j
    along_elem.attrib["d"] = new_path.d()
    # Then add the actual animateMotion tag
    return add_SMIL_tag(
        "animateMotion",
        E("mpath", href="#" + along),
        href="#" + which,
        dur=dur,
        # Easing
        calcMode="spline",
        keyPoints="0; 1",
        keyTimes="0; 1",
        keySplines="0.43 0.02 0.72 0.93",
        # Start from whereever it is right now, not the initial position
        additive="sum",
        # And after it arrives, it should stay there
        fill="freeze",
    )


@attr.s
class LineSeq:
    prefix = attr.ib()
    showing = attr.ib(default=0)
    first_missing = attr.ib(default=None)

    def __attrs_post_init__(self):
        # start with everything after {prefix}-0 hidden
        for i in count(1):
            if self._id(i) in by_id:
                hidden(self._id(i))
            else:
                self.first_missing = i
                break

    def _id(self, i=None):
        if i is None:
            i = self.showing
        return f"{self.prefix}-{i}"

    def next(self):
        with keep_time():
            animate(self._id(), 1, "opacity", to=0)
        self.showing += 1
        animate(self._id(), 1, "opacity", from_=0, to=1)
        # if self.showing + 1 < self.first_missing:
        #     # If this is an intermediate line, make it throb
        #     with keep_time():
        #         animate(
        #             self._id(), 1, "opacity",
        #             values="1; 0.5; 1",
        #             repeatCount="indefinite",
        #         )

    def finish(self):
        self.next()
        assert self.showing + 1 == self.first_missing

################################################################

hidden(
    "layer2",  # "Guides" layer -- can leave visible for debugging
    "hello",   # moving "hello" box
    "world",   # moving "world" box
    "receive-hello-arrow",  # -> next to first receive()
    "receive-world-arrow",  # -> next to second receive()
)

send_task_lines = LineSeq("task1")
receive_task_lines = LineSeq("task2")

def send_task_step(word, slide_dur):
    send_task_lines.next()
    sleep(0.5)
    with keep_time():
        animate(word, 1, "opacity", from_=0, to=1)
    slide(word, slide_dur, f"{word}-path-in")

def receive_task_step(word):
    receive_task_lines.next()
    slide(word, 3, f"{word}-path-out")
    with keep_time():
        animate(f"receive-{word}-arrow", 0.5, "opacity", to=1)
    animate(f"{word}-box", 1, "opacity", to=0)
    sleep(0.5)

sleep(0.5)
send_task_step("hello", 3)
send_task_step("world", 2.5)
send_task_lines.finish()
sleep(0.5)
receive_task_step("hello")
receive_task_step("world")
receive_task_lines.finish()

################################################################

doc.write(
    "anim2-2.svg", pretty_print=True, xml_declaration=True, encoding="UTF-8"
)
