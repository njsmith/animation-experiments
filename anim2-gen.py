import sys
import attr
from lxml import etree, builder
import subprocess
from itertools import count
from contextlib import contextmanager
import svgpathtools
import tinycss2

INPUT = "anim2-assets.svg"

# Removing blank text lets the pretty-printer work better
inkscape = subprocess.Popen(
    [
        "inkscape",
        INPUT,
        "--without-gui",
        "--export-text-to-path",
        # Inkscape 0.92.4 can use "-" here, but I have 0.92.3
        "--export-plain-svg=/dev/stdout",
    ],
    stdout=subprocess.PIPE,
)
# remove_blank_text=True allows the pretty-printer to work better
parser = etree.XMLParser(remove_blank_text=True)
doc = etree.parse(inkscape.stdout, parser)
svg = doc.getroot()

# Our own little getElementById
by_id = {}
for elem in doc.iter():
    if "id" in elem.attrib:
        assert elem.attrib["id"] not in by_id
        by_id[elem.attrib["id"]] = elem

svg.addprevious(etree.Comment(f"""
THIS FILE IS AUTOGENERATED, DO NOT EDIT DIRECTLY
source file: {INPUT}
"""))

def id_gen_fn():
    c = count()
    while True:
        yield f"animateStep{next(c)}"

id_gen = id_gen_fn()

@attr.s(frozen=True)
class TimeSpan:
    begin = attr.ib()
    end = attr.ib()

@attr.s(frozen=True)
class BaseTime:
    s = attr.ib()

    def __add__(self, offset):
        return f"{self.s} + {offset}s"

    def __sub__(self, offset):
        return f"{self.s} - {offset}s"

def obj_to_time(obj):
    if isinstance(obj, str):
        return obj
    elif isinstance(obj, (int, float)):
        return f"{obj}s"
    elif isinstance(obj, BaseTime):
        return obj + 0
    assert False

WHEN = None

@contextmanager
def at(when):
    global WHEN
    was = WHEN
    try:
        WHEN = obj_to_time(when)
        yield
    finally:
        WHEN = was

# Like lxml.builder.E, but with some extra conveniences:
# - adds required namespace to href=
# - strips trailing underscores so you can write from_=...
# - stringifies int/float attributes
def E(*args, **kwargs):
    fixed_kwargs = {}
    for k, v in kwargs.items():
        if k == "href":
            k = "{http://www.w3.org/1999/xlink}href"
        if k.endswith("_"):
            k = k.strip("_")
        if isinstance(v, (int, float)):
            v = str(v)
        fixed_kwargs[k] = v
    return builder.E(*args, **fixed_kwargs)

# Create element, add it to the svg, give it an id, and return a TimeSpan
def add_SMIL_tag(*args, **kwargs):
    elem = E(*args, **kwargs)
    new_id = next(id_gen)
    elem.attrib["id"] = new_id
    svg.append(elem)
    return TimeSpan(BaseTime(f"{new_id}.begin"), BaseTime(f"{new_id}.end"))

# There are a lot of ways to hide things in SVG/CSS â€“ display: none,
# visibility: 0, opacity: 0... we want to be able to fade hidden things in
# gradually, so that argues for using 'opacity'. But inkscape likes to stick
# 'opacity: 1' into style= attrs on individual elements, and those have high
# priority. We could use <set> to set "opacity: 0" on the first frame of the
# animation, but that can cause a flash of visibility... so instead we rewrite
# inkscape's style= attrs to remove the opacity:1, and then use CSS to set it.
# Kind of a big hammer, but it works.
def set_initial_css(which, name, value):
    which_elem = by_id[which]
    if "style" in which_elem.attrib:
        old_style = which_elem.attrib["style"]
        old_decls = tinycss2.parse_declaration_list(old_style)
        new_decls = [d for d in old_decls if d.name != name]
        which_elem.attrib["style"] = tinycss2.serialize(new_decls)
    svg.append(E("style", f"#{which} {{ {name}: {value}; }}"))

def start_hidden(*whiches):
    for which in whiches:
        set_initial_css(which, "opacity", 0)

# Add a SMIL <set> tag
def set(which, what, to):
    assert WHEN is not None
    add_SMIL_tag(
        "set",
        begin=WHEN,
        href="#" + which,
        attributeName=what,
        to=to,
        fill="freeze",
    )

# Add a SMIL <animate> tag
def animate(which, dur, what, **kwargs):
    assert WHEN is not None
    return add_SMIL_tag(
        "animate",
        begin=WHEN,
        href="#" + which,
        dur=dur,
        fill="freeze",
        attributeName=what,
        **kwargs
    )

# Add a SMIL <animateMotion> tag for motion along an SVG path
def slide(which, dur, along):
    assert WHEN is not None
    # Now we know that 'along' is being used as a motion path, rewrite the
    # path so that it starts at the origin.
    along_elem = by_id[along]
    assert along_elem.tag == "{http://www.w3.org/2000/svg}path"
    path = svgpathtools.parse_path(along_elem.attrib["d"])
    new_path = path.translated(-path[0].start)
    assert new_path[0].start == 0+0j
    along_elem.attrib["d"] = new_path.d()
    # Then add the actual animateMotion tag
    return add_SMIL_tag(
        "animateMotion",
        E("mpath", href="#" + along),
        begin=WHEN,
        href="#" + which,
        dur=dur,
        # Easing
        calcMode="spline",
        keyPoints="0; 1",
        keyTimes="0; 1",
        keySplines="0.43 0.02 0.72 0.93",
        # Start from whereever it is right now, not the initial position
        additive="sum",
        # And after it arrives, it should stay there
        fill="freeze",
    )


@attr.s
class LineSeq:
    prefix = attr.ib()
    showing = attr.ib(default=0)
    first_missing = attr.ib(default=None)

    def __attrs_post_init__(self):
        # start with everything after {prefix}-0 hidden
        for i in count(1):
            print(self._id(i))
            if self._id(i) in by_id:
                start_hidden(self._id(i))
            else:
                self.first_missing = i
                break

    def _id(self, i=None):
        if i is None:
            i = self.showing
        return f"{self.prefix}-{i}"

    def next(self):
        first = animate(self._id(), 1, "opacity", to=0)
        self.showing += 1
        middle = animate(self._id(), 1, "opacity", from_=0, to=1)
        if self.showing + 1 == self.first_missing:
            # If this is the last line, skip the throb
            return TimeSpan(first.begin, middle.end)
        else:
            with at(middle.end):
                last = animate(
                    self._id(), 0.5, "opacity", from_=0.5, to=1, repeatCount=3,
                )
            return TimeSpan(first.begin, last.end)


# This is the "Guides" layer in inkscape
set_initial_css("layer2", "display", "none")
start_hidden("hello", "world", "receive-hello-arrow", "receive-world-arrow")

task1_lines = LineSeq("task1")

def task1_step(begin, word):
    with at(begin):
        line_throb = task1_lines.next()
    with at(line_throb.end + 1):
        fade_in_word = animate(word, 1, "opacity", from_=0, to=1)
    with at(fade_in_word.end - 0.5):
        slide_word = slide(word, 3, f"{word}-path-in")
    return TimeSpan(begin, slide_word.end)

task1_step1 = task1_step(0.5, "hello")
task1_step2 = task1_step(task1_step1.end, "world")
with at(task1_step2.end):
    task1_lines.next()

doc.write(
    "anim2-2.svg", pretty_print=True, xml_declaration=True, encoding="UTF-8"
)
